local settings = {
    prediction = 0.165,
    fovRadius = 150,
    fovCircleVisible = true,
    fovColor = Color3.fromRGB(255, 255, 255),
    fovThickness = 1,
    fovTransparency = 1,
    fovNumSides = 100,
    TeamCheck = false,
    silentAimKey = Enum.KeyCode.C,
    smoothAim = true,
    smoothFactor = 0.15,
    prioritizeHead = true,
    enableKeybinds = true
}

local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()

local guiInset = GuiService:GetGuiInset()

local FOV = Drawing.new("Circle")
FOV.Visible = settings.fovCircleVisible
FOV.Radius = settings.fovRadius
FOV.Color = settings.fovColor
FOV.Thickness = settings.fovThickness
FOV.NumSides = settings.fovNumSides
FOV.Transparency = settings.fovTransparency
FOV.Filled = false

local silentAimActive = false
local target = nil
local targetPart = nil

local function isVisible(pos, ignore)
    local params = RaycastParams.new()
    params.FilterDescendantsInstances = {LocalPlayer.Character, ignore}
    params.FilterType = Enum.RaycastFilterType.Blacklist
    local origin = Camera.CFrame.Position
    local direction = (pos - origin)
    local result = workspace:Raycast(origin, direction.Unit * direction.Magnitude, params)
    return not result
end

local function getClosestPlayer()
    local closest = nil
    local shortestDist = math.huge
    for _, v in pairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
            if settings.TeamCheck and (v.Team == LocalPlayer.Team) then continue end
            local part = settings.prioritizeHead and v.Character:FindFirstChild("Head") or v.Character:FindFirstChild("HumanoidRootPart")
            if part then
                local predictedPos = part.Position + (part.Velocity * settings.prediction)
                local screenPos, onScreen = Camera:WorldToViewportPoint(predictedPos)
                if onScreen then
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
                    if dist < settings.fovRadius and dist < shortestDist then
                        if isVisible(predictedPos, v.Character) then
                            closest = v
                            shortestDist = dist
                        end
                    end
                end
            end
        end
    end
    return closest
end

local function getTargetPart(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then return nil end
    return settings.prioritizeHead and targetPlayer.Character:FindFirstChild("Head") or targetPlayer.Character:FindFirstChild("HumanoidRootPart")
end

-- Create Draggable Button
local screenGui = Instance.new("ScreenGui", LocalPlayer.PlayerGui)
local shootButton = Instance.new("TextButton", screenGui)

shootButton.Size = UDim2.new(0, 30, 0, 30)
shootButton.Position = UDim2.new(0.5, -15, 0.5, -15)
shootButton.Text = "Shoot"
shootButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
shootButton.TextColor3 = Color3.fromRGB(255, 255, 255)

-- Draggable function
local dragging = false
local dragInput, startPos, startMousePos

local function updateDrag(input)
    local delta = input.Position - startMousePos
    shootButton.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

shootButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        startMousePos = input.Position
        startPos = shootButton.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

shootButton.InputChanged:Connect(function(input)
    if dragging then
        updateDrag(input)
    end
end)

-- Silent Aim Activation
UIS.InputBegan:Connect(function(input)
    if not settings.enableKeybinds then return end
    if input.KeyCode == settings.silentAimKey then
        silentAimActive = not silentAimActive
    elseif input.KeyCode == Enum.KeyCode.H then
        settings.prioritizeHead = true
    elseif input.KeyCode == Enum.KeyCode.B then
        settings.prioritizeHead = false
    end
end)

RunService.RenderStepped:Connect(function()
    if settings.fovCircleVisible then
        FOV.Position = Vector2.new(Mouse.X, Mouse.Y + guiInset.Y)
    end
    if not silentAimActive then
        target = nil
        targetPart = nil
        return
    end
    target = getClosestPlayer()
    targetPart = getTargetPart(target)
end)

local __index
__index = hookmetamethod(game, "__index", function(self, key)
    if self == Mouse and (key == "Hit" or key == "Target") then
        if target and targetPart then
            local predictedPos = targetPart.Position + (targetPart.Velocity * settings.prediction)
            if settings.smoothAim then
                local currentPos = Camera:ScreenPointToRay(Mouse.X, Mouse.Y).Origin
                local smoothPos = currentPos:Lerp(predictedPos, settings.smoothFactor)
                return (CFrame.new(smoothPos)).Position
            else
                return predictedPos
            end
        end
    end
    return __index(self, key)
end)

shootButton.MouseButton1Click:Connect(function()
    if target and targetPart then
        local predictedPos = targetPart.Position + (targetPart.Velocity * settings.prediction)
        if settings.smoothAim then
            local currentPos = Camera:ScreenPointToRay(Mouse.X, Mouse.Y).Origin
            local smoothPos = currentPos:Lerp(predictedPos, settings.smoothFactor)
            -- Implement shoot action here
        else
            -- Implement shoot action here
        end
    end
end)
